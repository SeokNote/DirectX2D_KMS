
03-14 문법강의

funtional 아무 함수들을 받아서 사용할수있다. 
펑셔널 사용해보기
인자 여러개해보기
sharedptr;


순환참조가 일어나면 왜 릭이 남는지 알아보기

03-15  파일 입출력 
프로젝트를 다시 만들 때 어떻게 갖고오고 디렉토리 설정 어떻게하는지 다시 보기 (강의참고하며)
종속성 체크 다중프로그렘 설정 디렉토리 설정
스태틱 기반 프레임워크 짠다
메모리 단편화 : 힙메모리  기억 장치의 빈 공간 또는 자료가 여러 개의 조각으로 나뉘는 현상을 말한다. 이 현상은 기억장치의 사용 가능한 공간을 줄이거나, 읽기와 쓰기의 수행속도를 늦추는 문제점을 야기한다.힙 메모리에서 new 나 Delet의 속도가 준다.
램과 cpu의 관계
램은 값을 갖는 곳 그 값을 받아 계산하는 곳이 cpu고 그 값을 다시 렘에 저장한다

Vector와 map의 차이
벡터는 배열형태로 저장하기 떄문에 램에 저장위치가 붙어있어 cpu에서의 연산에서
캐쉬메모리에 정보를 한번만 올리면 되지만 map은 new를 사용하여 동적할당을 하기 때문에
렘에서의 위치가 불분명해 캐쉬메모리의 값이 바뀔수도 있어서 속도가 더 느려질수가 있다.
그래서 100개이하의 값을 찾을때는 벡터가 더 빠르다.
캐쉬메모리:cpu가 당장 처리해야할 일들을 복사해서 담아놓는 곳
캐쉬적중률 : 
포인터는 따로 저장할 필요가 없다.

직렬화:복습하고 wriht  save 복습: 
03-16 
Write load loadbin read
강의 걍 보셈
03-17 
엔진은 자기가 무슨 게임을 만들지 무슨 레벨을 만들지 모른다.
클래스 응집도,결합도
후반부 메모
타임 이벤트 매니저
몇초마다 무언가 해라. 라는 내용을 갖는 함수,
Emplace_back : 기본생성자를 만들어서 넣어준다 일반적인 push_back 처럼 생성자를 만들어서 넣는게 아니다.(벡터의 기능)
03-20
 초반 컴퓨터 바꿈 이슈로 인한 환경변수 셋팅
자격증명 관리를 통해 깃 아이디 바꿀 수 있음
벡터는 중간에 삭제가 힘들다 왜냐하면 동적할당으로 구조를 짜 놓았기 때문이다.
벡터의 erase는 리스트보다 느리다. 이유는 모르겠음 찾아보자
그렇기 때문에 타임 이벤트 매니저는 리스트로 구현한다.



람다함수: 사용 함수의 이름이 없이 사용되는 것.
벨류캡쳐 [a] a를 새로 만들겠다는 의미
[&A] A를 레퍼런스로 가져오겠다는 의미
[=] 눈의 보이지 않지만 []안에서 새로 만들어 받아 복사해서 쓰는것.

GameEngineObject :레벨을 상속받는다
문자열의 복사를 막기위해 string view를 사용하였습니다 즉 최적화.
String은 벡터기 때문에 문자가 들어오면 새로 new해서 (동적할당을 하여) 공간을 만든다. 최적화 이유
String_View 는 const char*로 받아와서 쓰기 때문에 문자열의 복사가 나타나지 않는다
이제부터 shard_ptr 사용한다 다시보자

03-21
순환참조 알아보기
Actor 와 Render 
->PlayLevel , Actor 
소멸자 가상함수 순수가상함수.
3D의 기본구조
엔진이 다 처리하지만 원리를 알아야한다.
3d를 화면에 띄운다는 것은 3차원의 이미지를 2차원에 표현하는 느낌으로 가야한다.
수학공식을 이용하여 띄울 것.
MASH: 면 또는 솔리드 형상을 나타내는 사각형과 삼각형의 모음 ex) 정육면체의 매쉬는 8개이다.
Vertexs : 버텍스란 하나의 '점'이다. 정점이라 하며 3D의 가장 기본단위다 
Polygon
크자이 공부
크기/자전/이동/공전/부모 순서대로 적용시켜야한다 . 공간변환의 순서
03-22
좌표계부터 이해 ,왼손 좌표계
벡터의 정의:
벡터의 덧샘: 플레이어의 이동
벡터의 뺄셈: 다른 오브젝트의 위치를 알고싶을 때 즉 서로 바라보기쉬울 때 
벡터의 곱셈 :방향은 유지하되 길이만 커지는 것
어떤 벡터를 만들건 그 벡터는 직각삼각형이 된다
Nomalize()
호돈법이란 180도 = 파이 , 90도 2/1파이
크자이공부 (크기 자전 이동을 바꿔서 실행하며 벡터의 느낌을 알자)
크기: 벡터의 곱셈
자전: 
이동: 벡터의 더하기
공전:
부모:
삼각함수 : 삼각형을 구성하는 3개의 선의 나눗셈은 삼각형이 커지든 비율이 같다.
360분법
벡터의 회전 증명
리턴 본체는 바꾸지 않고 내상태에서 변형된 얘를 리턴해준다
03-23







백터의 외적 : 쓰이는 상황은 면의 앞과 뒤를 알려고 할 때 적을 향해 돌아야 할 때 쓰인다.
Lx, Ly Lz Lx 1 0 0 1
Rx, Ry Rz Rx 0 1 0 0
Z = Lx*Ry -Ly-Rx = +1
X = Ly*Rz -Lz-Ry = 0
Y = Lz*Rx -Lx-Rz = 0 
백터의 외적은 3D에 있어 엄청 중요한 것이다. 

법선벡터 : 각 면에서 수직으로 나오는 벡터 즉 정육면체는 6개의 법선벡터가 있다.
행렬:
행렬의 곲셈에서 교환법칙이 적용되지 않는 이유는 크자이 공부에 예를 들면 크자이 순서가 바뀌면 결과가 아예 달라져서
행렬에서 4*4 x 4*4 의 곱셈은 2차원배열을 이용해 for문을 돌린다 . 쉽게돌리기위해 유니온 공부
항등행렬, 유일하게 교환법칙이 적용되는 행렬로 어떤행렬을 여기에 곱해도 그행렬이 나온다
1	0	0	0
0	1	0	0
0	0	1	0
0	0	0	1

제로행렬 : 아무거나 곱해도 다 0이다
0	0	0	0
0	0	0	0
0	0	0	0
0	0	0	0



유니온
->유니온 안에 선언된 변수들은 그 공간을 공유한다. 그렇기 때문에 유니온의 크기는 그 변수내의 가장 큰 메모리로 결정된다. 
03-27
직접 가장 간단한 행렬을 만들어서 외적을 해보자
Value1 {1,0,0,0}
Value2 {0,1,0,0}
Z=1
하지만 z값이 0일 경우가 있다
-> ex)플레이어와 몬스터가 일직선상에 있어 보고있는지 뒤에있는지 모를 경우.
Scale 과 행렬
스케일을 키울때도 행렬을 이용하여 키울수 있다
항등행렬이 100인 행렬을 곱해서 크기를 100배 키울수 있다.
위치(이동) 와 행렬 : w의 역할과 의미를 알 수 있다. + float4를 쓴 이유
코드 보자 
Worldmat : 행렬을 쓰는 이유중하나 복습하자
->크기,자전.이동을 한번에 처리하는 것.
회전과 행렬
Float4 dir [1][0][0][1] 인 벡터가 있다
->이 벡터는 x축으로 가는 벡터이다
.
.
.

03-28 녹화o
짐벌락 현상이라는 것도 있다~
4원수회전 = 쿼터니온

뷰행렬
Gameenginecamara
GameengineTransform


03-29 다시 보기 디버깅해보기 LookAtLH 디버깅.
뷰행렬 마저하기
함수를 실행한다는건 실행하기위한 실행메모리를 할당한다 = 스택메모리
즉 함수를 호출하는건 조금 더 느리다
하지만 인라인을 사용하게 되면 
메크로함수 : 컴파일이 어려움 그래서 인라인을 쓰면 가독성에 좋고 컴파일이 쉽다

벡터
외적을 통해 얼마나 돌아야하는지 알고
내적을 통해서 몇도를 돌아야하는지 알수있다.
로컬이 왜 붙는지 추후 설명
03-30 오늘부터 다이렉트 조금 쓸 것 녹화 O 
역행렬
전치행렬
뷰행렬
원근투영 : 탄젠트를 이용해 비율 계산
직교투영
03-31 지금까지 만들었던 것들을 다 다이렉트 함수로 적용시키기.
뷰포트 : 원근투영을 하게 되면 값이 -1~1사이라 눈에 안보이기 때문에
그 크기를 화면 크기만큼 확장시키는 개념이다.


04-03
엔진 구조 변경의 날 걍 녹화보자
04-04

04-05 사원수 행렬 오일러 Decompose
다이렉트 x 는 함수를 잘써야한다. 내부구조 조금

04-06 이제부터 다이렉트 시작.
GameEngineDevice
원래 api 는 백버퍼를 이용해서 작업했지만 (cpu연산)
Directx 부터는 디바이스를 사용해 어뎁터로 그래픽카드와 연동해서 사용한다.(그래픽카드연산)

04-07
멀티쓰레드.
렌더타겟: 화면에 하나뿐인 윈도우에 그림을 그릴수있는 DC이다.
즉 렌더타겟에 그려야만 화면에 나온다. ( 어떤 이미지 즉 그림을 그릴수 있는 권한)





04-105
Transform 구조 변경
AbsoluteScale
AbsoluteScale
AbsoluteScale
을 통해 바꿔보려 했지만 좀더 생각한후 변경하신다함
텍스쳐 띄우기. (이미지)
오늘은 렌더링파이프라인 설명후 수업끝.
굉장히 중요!
랜더링 파이프라인의 단계 (이단계대로 하지 않아도 된다. 즉 단계가 뒤섞여도된다 왜냐하면 이는 각각에 그리기 위한 필요한 요소들을 셋팅해주는 단계이기 때문에 다 채워지기만 하면 그릴수있다.)
PPt로 정리하기.
04-11 랜더링 파이프라인의 처음인 IA 처음부분
04-12 버텍스 쉐이더 + IA 의 두번째 단계
인덱스 버퍼만듦
04-13
랜더링 파이프라인의 단계에든 2가지 단계가 있다
고정기능단계
(resterizer)

레스터라이저 단계
GameEngineRenderingPipeLine 쪽 cpp참고 
레스터라이저 단계에서 레스터라이저에 만들때 필요한옵션값들이 상세하게 적혀있음
레스터라이저 세팅에 가보면 Desc의 기본값을 세팅해줌

픽셀 쉐이더 단계

아웃풋머저 단계
랜더타겟(도화지) 을 정해주는 단계인데 픽셀 쉐이더까지 다 된 후에 어디에 그릴건지 정해준다 도화지를 여러개 깔아줄수도있다.

토폴로지 : 컴퓨터 네트워크의 요소들(링크, 노드 등)을 물리적으로 연결해 놓은 것 즉 어떤방식으로 그려서 만들지 현재 엔진에서는 삼각형으로 렌더해서 텍스처를 구성함.
인풋레이아웃 : 버텍스에 쉐이더에 들어갈 요소들중 첫번째로 들어오는게 어떤건지 알려주기 위한 함수이다. 우리 코드에선 첫번째가 포지션 두번째가 칼라이다.
HLSL에서 하는일
인풋 ->   텍스터VS ->        아웃풋 ->                                            텍스쳐PS->                                      아웃컬러
(정보를갖고)  (정보를이용해)  (아웃풋구조체의 결과를 리턴해서 텍스쳐ps에 넣어줘) ->   (들어온 정보로 칼라를 셋팅해서 아웃칼러고 리턴해줘) (그 칼라값을 어디에 그릴지를 정해주는것.)

시멘틱인덱스 : 여러개의 포지션을 표현하기 위한 변수 하지만 여기 엔진은 0개이다. 즉 포지션은 한개밖에존재하지않음

04-17 녹화o
쉐이더 리플렉션 : 쉐이더의 정보를 갖고있음
우리의 엔진 구조는 파이프와 쉐이더헬퍼와 합쳐져서 랜더링이 된다.

t – SRV(셰이더 리소스 뷰)
s – 샘플러
u – UAV(순서가 지정되지 않은 액세스 뷰)
b – CBV(상수 버퍼 보기)

04-18
ShaderResHelper 는 쉐이더도 갖고 리소스도 공통으로 갖고있는 것이다. 현재까지 구조에서는 쉐이더헬퍼는 상수버퍼세터만 갖고있는데 
하나에 파이프라인을 사용할때 여러개의 리소스를 로드하게 되면 리소스마다 원하는 색이나 등등이 다 다르기 때문에 쉐이더가 갖고있는
쉐이더헬퍼의 상수버퍼세터를 복사하여 리소스도 들고있게 한다 그후 리소스에서 세팅해서 넘겨주는식이다.

멀티맵
Low_bound
Upper_bound


세터부분에서 map이 있는 이유는 이제 상수버퍼의 값을 바꿔야하기 때문이다.
map() 그래픽카드를 잠깐 멈추게하는 함수기 때문에 상당히 느려진다.
첫번째인자로 고쳐질 버퍼 두번째 인자로 0, 세번째 인자로 타입이 오는데 그냥 최대한빠르게 처리하라는 뜻
다쓰면 unmap

04-19
카메라의 원근인지 직교인지 세팅함
카메라의 프리카메라 기능을 만듦
마우스 위치에 따라 카메라를 이동시키는 기능
트랜스폼 수정
하위파일을 다 돌며 원하는 파일을 다 로드하는 기능을 만듦


갑자기 든 생각 : 플레이어의 위치와 카메라를 고정시켜놓고 그떄의 위치값을 받아놓는다
그위치값을 반으로 나눈것을 기점으로 반값보다 작아지면 LEFT 커지면 RIGHt로 할수 있지 않을까


04-20
UV좌표계 : 건져나오는 즉 매쉬에 그려질 범위와 그리고싶은 텍스쳐의 크기를 둘다 선형보간 즉 러프를 통해 비율별 값으로 치환?
texcoud : 텍스쳐 정규값.
디퓨즈 텍스쳐 : 표면색상???검색해보자
셈플러란 : 이미지의 크기배율?

04-21
던그리드에서 미러를 쓸까?

04-24 :

침습형 카운터.
Local Static
Alpha Blend;
랜더타겟에 이미 깔려있는 색 : DestColor
이미지의 컬러 : SourseColor 

04-25 :
동영상 기능 업데이트
Update분리
TransForm 구조 변경
Depth  : 깊이 버퍼
stencil:


화면 크기만큼의 텍스터를 또 만든다.
깊이버퍼 텍스처(깊이버퍼를 위해 또 만든 텍스처)  백버퍼 텍스처 (기존 덱스처)
따로 만든 텍스처에 예를들면 먼저 그려질 이미지의 z값을 해당 픽셀에 넣는다
그리고 다음이 그뒤에 그려져야할 그림이라고 생각하자
z값은 먼저 그려져야 할 이미지의 z값을 따로 만든 텍스처에 넣어준다
그 후 그려질 그림이 그려지는데 곂치는 그 픽셀에 해당 z값을 넣는데
먼저 대입된 z값이 더 작다면 대입이 불가하다. 즉 z값이 작은값이 출력된다.

일단 옵션값은 내일 설명해주신다함.



다음달 중순부터 화 목은 검사함


숙제 : 블랜드 복습하기. 블랜드 합치기

04-26
